---
title: 'C++ 类型转换'
layout: post
tags:
  - cpp
category: Program
---
C++的类型转换比较杂，看了又忘，再看也忘。在此，总结了一下。

<!--more-->

## 隐式转换

### 何时发生隐式转换

 * 在大多数表达式中，比`int`类型小的整型值首先提升为较大的整数类型（整型提升）。
 * 在条件中，非布尔值转换成布尔类型。
 * 初始化过程中，初始化值转换成变量类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
 * 如果算术运算或关系运算的运算有多种类型，需要转换成一种类型（算术转换）。
 * 函数调用时也会发生类型转换。

### 转换规则

#### 算术转换：

运算符的对象转换成最宽的对象。当表达式中既有浮点型也有整型类型时，整型值也转换成浮点型。
 
 #### 整型提升
 
 小整数类型转换成较大的整数类型，对于`bool`、`char`、`signed char`、`unsigned char`、`short`和`unsigned short`，只要它们所有可能的值都能存在`int`里，它们就会提升成`int`类型，否则提升成`unsigned int`类型。
 
 较大的`char`类型（`wchar_t`、`char16_t`、`char32_t`）提升成`int`、`unsigned int`、`long`、`unsigned long`、`long long`和`unsigned long long`中最小的一种类型。
 
 #### 无符号类型的运算对象
 
 首先进行整型提升，提升后如果符号相同则小类型转换大类型。如果符号不同，而其中无符号类型不小于带符号类型，则都转成无符号的；如果带符号类型大于无符号类型，如果无符号类型的所有值都能存在带符号类型中，则无符号转成带符号，如果不能，那么带符号转换无符号。
 
 #### 其它隐式类型转换
 
 * 数组自动转换成指针。
 * 指针的转换：`nullptr`能转换成任意指针类型；指向任意非常量的指针能转换成`void*`；指向任意对象的指针能转换成`const void *`；继承关系指针的转换。
 * 转换成布尔类型：如果指针或算术类型的值为0，转换结果为`false`；否则转换结果是`true`。
 * 转换成常量：指向 T 的指针或引用分别转换成指向`const T`的指针或引用（顶层`const`）。
 * 类类型定义的转换。

 ### 显式转换

* `static_cast`：只要不包含底层`const`，都可以使用`static_cast`。
* `const_cast`：只能改变运算对象的底层`const`，如果对象本身是一个常量，那么行为未定义。
* `reinterpret_cast`：为运算对象的位模式提供较底层次上的重新解释。
* 旧式强制类型转换：
	```
	type (expr);
	(type) expr;
	```